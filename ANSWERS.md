# 25. Спекуляция. Спекулятивный суперскалярный процессор. Основные этапы исполнения инструкций
**Спекуляция** — выполнение некоторой операция, необходимость выполнения которой носит вероятностный характер.

ССП способен выполнять инструкции, которые следуют за невыполненной инструкцией условного перехода, основываясь на данных предсказателя ветвления, и в случае неверного предсказания выполнять откат.

Этапы исполнения инструкции ССП
1. Выборка инструкции
2. Планирование инструкции
3. Ожидание готовности операндов
4. Исполнение
5. Запись результата
6. Завершение (commit)

**Дальше под вопросом потому что хз надо это или нет**

Стадии записи результата и завершения
1. Стадия записи результата:
    - результат работы инструкции помещается в промежуточное хранилище, а не восновной регистровый файл
2. Стадия завершения:
    - проверка корректности исполнения инструкции
    - генерируются исключения, если необходимо
    - записывается результат из временного хранилища в основной регистровый файл

Изменения в аппаратной схеме
1. добавлен: буфер упорядочивания (reorder buffer)
    - используется для:
        - хранение результатов работы инструкций между стадией записи результата и стадией завершения
        - поддержка программного порядка инструкция на стадии завершения
    - элемент БУ содержит:
        - выполняемую инструкцию: арифметическая, загрузка, сохранение, условный переход
        - адрес результата инструкции
        - поля для временного хранения результата инструкции
1. удален: буфер сохранения

Этап планирования
- планирование инструкций осуществляется с вершины очереди инструкций
- для выполнения планирования должны быть доступна СР на требуемом ФУ и
ячейка на БУ, если хотя бы один из ресурсов не доступен, инструкция ожидает в
очереди
- выборка операндов состоит из трех стадий:
    - проверяются есть ли данные в регистровом файле, если есть переписываются в СР, если нет, то
    - проверяются, есть ли данные в БУ, если есть – переписываются в СР, если нет, то
    - в СР записывается номер ячейки БУ, которая содержит инструкцию, которая
вычислит этот операнд
- в файл переименования для результирующего регистра инструкции
помещается номер ячейки БУ, которая ее содержит

Этап исполнения и записи результата
- инструкции запускаются на исполнении по мере готовности их операндов и
доступности ФУ
- по общей шине передается результат инструкции и номер ячейки БУ, которая ее
содержит
- запись результата выполняется одновременно во все ожидающие СР и БУ
- инструкция загрузки выполняется в две стадии:
    - вычисление адреса
    - чтение из памяти. Запускается, если нет конфликтов с предыдущими
инструкциями загрузки и сохранения
- инструкция сохранения на этапе исполнения вычисляет адрес операнда и
ожидает готовности результата, запись в память произойдет на стадии
завершения

Этап завершения
- инструкция после вычисления результата ожидает в БУ своего завершения
- завершаются инструкции, которые находятся на вершину БУ. БУ поддерживает поведение очереди FIFO
- на этапе завершения:
    - для арифметических инструкции и инструкции загрузки проверяется наличие
исключений и если исключений нет, результат записывается в регистровый файл
    - для инструкции сохранения проверяется наличие исключений и если исключений нет, результат записывается в память
    = для инструкции условного перехода проверяется правильно она была
предсказана или нет, если да, инструкция удаляется из БУ, если нет, происходит сброс процессора: очищаются все стадии, на планирование отправляется первая инструкция из правильной ветви
# 26. Алгоритм Томасуло. Планирование инструкций
**Состав процессора(для удобства, но по идее не надо)**
- Очередь планирования (Instruction queue)[ОП] 
- Регистровый файл (FP Registers) [РФ]
- Станции резервирования (Reserve Station) [СР]
- Простое вещественное устройство (FP adder)
- Сложное вещественное устройство (FP Muliplier)
- Общая шина данных (Common Data Bus)[ОШД]
- Устройство вычисление адреса (Address Unit)
- Буфера загрузки (Load buffer)
- Буфера сохранения (Store buffer)
- Устройство работы с памятью (Memory Unit).

**Алгоритм Томасуло** — Это алгоритм динамического планирования инструкций, 
который позволяет исполнять инструкции в порядке отличном от программного.

- При одновременном исполнении двух и более инструкций позволяет разрешить
RAW, и устранить WAR и WAW конфликты
- Разрешение конфликтов RAW происходит за счет запуска инструкции, только когда
готовы ее операнды.
-  Устранение WAR и WAW конфликтов происходит за счет переименования регистров
с использованием станций резервирования (Reserve Station).
- RS используются для хранения операндов инструкции и воссоздания графа
зависимостей по данным между инструкциями, которые находятся в исполнении.

1. Выборка с вершины ОП.
    - Выборка происходит по 1 инструкции за такт.
    - Выборка осуществляется в программном порядке, так как очередь FIFO
1. Декодирование.
1. Назначение на исполнительное устройство.
    - Если все СР устройства заняты, то инструкция возвращается в ОП и
 ожидает освобождения RS.
1. Выборка операндов.

Если операнды вычислены, то они выбираются из РФ, если нет, то в дескрипторах СР
устанавливается ссылки на другие СР.

**Ожидание готовности операндов, исполнение, сохранение результатов**
- Инструкция ожидает в СР до тех пор, пока не будут вычислены все ее операнды и
 записаны в соответствующие дескрипторы.
- Передача вычисленного операнда происходит по ОШД вместе с номером СР, который его
 содержал
- Каждая СР слушает ОШД и сравнивает значение номер передаваемого по ней СР с
 ожидаемым. Если номера совпадает то она забирает значение операнда с ОШД
- Передаваемые по ОШД данные сохраняются в РФ.
- Если все операнды находятся СР, то инструкция отправляется на исполнение.

**Обработка инструкций загрузки и сохранения**
- Инструкция загрузки:
    - Вычисление адреса
    - Выполнение загрузки по адресу
- Инструкция сохранения:
    - Вычисление адреса
    - Ожидания готовности операнда
    - Выполнение сохранения по адресу.
- Буфер загрузки: поле адреса
- Буфер сохранения: поле адреса, СР для операнда


# 27. Алгоритм Томасуло. Состав процессора. Этапы исполнения инструкций
**Алгоритм Томасуло** — Это алгоритм динамического планирования инструкций, 
который позволяет исполнять инструкции в порядке отличном от программного.

- При одновременном исполнении двух и более инструкций позволяет разрешить
RAW, и устранить WAR и WAW конфликты
- Разрешение конфликтов RAW происходит за счет запуска инструкции, только когда
готовы ее операнды.
-  Устранение WAR и WAW конфликтов происходит за счет переименования регистров
с использованием станций резервирования (Reserve Station).
- RS используются для хранения операндов инструкции и воссоздания графа
зависимостей по данным между инструкциями, которые находятся в исполнении.

**Состав процессора**
- Очередь планирования (Instruction queue)[ОП] 
- Регистровый файл (FP Registers) [РФ]
- Станции резервирования (Reserve Station) [СР]
- Простое вещественное устройство (FP adder)
- Сложное вещественное устройство (FP Muliplier)
- Общая шина данных (Common Data Bus)[ОШД]
- Устройство вычисление адреса (Address Unit)
- Буфера загрузки (Load buffer)
- Буфера сохранения (Store buffer)
- Устройство работы с памятью (Memory Unit).

**Этапы исполнения инструкции**

Классический конвейер
- Выборка инструкции
- Выборка операндов
- Исполнение
- Сохранение результата

Алгоритм Тамасуло
- Выборка инструкции
- Планирование инструкции
- Ожидание готовности операндов
- Исполнение
- Сохранение результата
# 28. Спекулятивный суперскалярный процессор
**черт знает что он хочет**
ССП способен выполнять инструкции, которые следуют за невыполненной инструкцией условного перехода, основываясь на данных предсказателя ветвления, и в случае неверного предсказания выполнять откат. 

**Информация дальше просто есть, не знаю, куда ее пристроить**

Стадии записи результата и завершения
1. Стадия записи результата:
    - результат работы инструкции помещается в промежуточное хранилище, а не восновной регистровый файл
2. Стадия завершения:
    - проверка корректности исполнения инструкции
    - генерируются исключения, если необходимо
    - записывается результат из временного хранилища в основной регистровый файл

Изменения в аппаратной схеме
1. добавлен: буфер упорядочивания (reorder buffer)
    - используется для:
        - хранение результатов работы инструкций между стадией записи результата и стадией завершения
        - поддержка программного порядка инструкция на стадии завершения
    - элемент БУ содержит:
        - выполняемую инструкцию: арифметическая, загрузка, сохранение, условный переход
        - адрес результата инструкции
        - поля для временного хранения результата инструкции
1. удален: буфер сохранения

Этап планирования
- планирование инструкций осуществляется с вершины очереди инструкций
- для выполнения планирования должны быть доступна СР на требуемом ФУ и
ячейка на БУ, если хотя бы один из ресурсов не доступен, инструкция ожидает в
очереди
- выборка операндов состоит из трех стадий:
    - проверяются есть ли данные в регистровом файле, если есть переписываются в СР, если нет, то
    - проверяются, есть ли данные в БУ, если есть – переписываются в СР, если нет, то
    - в СР записывается номер ячейки БУ, которая содержит инструкцию, которая
вычислит этот операнд
- в файл переименования для результирующего регистра инструкции
помещается номер ячейки БУ, которая ее содержит

Этап исполнения и записи результата
- инструкции запускаются на исполнении по мере готовности их операндов и
доступности ФУ
- по общей шине передается результат инструкции и номер ячейки БУ, которая ее
содержит
- запись результата выполняется одновременно во все ожидающие СР и БУ
- инструкция загрузки выполняется в две стадии:
    - вычисление адреса
    - чтение из памяти. Запускается, если нет конфликтов с предыдущими
инструкциями загрузки и сохранения
- инструкция сохранения на этапе исполнения вычисляет адрес операнда и
ожидает готовности результата, запись в память произойдет на стадии
завершения

Этап завершения
- инструкция после вычисления результата ожидает в БУ своего завершения
- завершаются инструкции, которые находятся на вершину БУ. БУ поддерживает поведение очереди FIFO
- на этапе завершения:
    - для арифметических инструкции и инструкции загрузки проверяется наличие
исключений и если исключений нет, результат записывается в регистровый файл
    - для инструкции сохранения проверяется наличие исключений и если исключений нет, результат записывается в память
    = для инструкции условного перехода проверяется правильно она была
предсказана или нет, если да, инструкция удаляется из БУ, если нет, происходит сброс процессора: очищаются все стадии, на планирование отправляется первая инструкция из правильной ветви

# 29. EPIC. Механизмы поддержки спекуляции
**EPIC (explicit parallel instruction set)** — Архитектура с явным параллелизмом на уровне инструкций. 
- Призвана сохранить достоинства VLIW архитектуры и устранить ее
 недостатки
- Достоинства VLIW и EPIC: возможность параллельного исполнения
 инструкций задается на уровне архитектуры, а не определяется динамически в
 процессе исполнения
-  Недостаток VLIW устраненный EPIC: решена проблема бинарной
 совместимости между различными процессорами

**Спекуляция по данным**
- Компилятор переносит инструкцию настолько вверх, насколько нужно, не
 обращая внимание на возможные конфликты.
- Перед инструкцией потребителем данных вставляется специальная
 инструкция проверки, которая проверяет были ли сохранения по целевому
 адресу после запуска инструкции загрузки.
- Если произошел конфликт, то инструкция проверки может сгенерировать
 исключение или выполнить обычную загрузку.

**Спекуляция по управлению в EPIC основано на:**
- Наличие двух типов инструкций: спекулятивных и неспекулятивных
- Параллельном исполнении спекулятивных инструкций из двух ветвей
- Использование предикатирования для выбора результата корректной
ветви.
- Использование третьего состояния регистров для сохранения
поведения исключений во время спекуляции.
# 30. EPIC. Пакет инструкций – способ явного задания параллелизма уровня команд
**Пакет инструкций (тоже хз, что-то мало в лекциях)**
- Состоит из слотов инструкций и шаблона
- Шаблон определяет:
    - Тип инструкций в слотах
    - Расположения разделителя последовательности инструкций
- Инструкции в последовательности является независимыми и запускаются
процессором в произвольном порядке по мере готовности устройств.
- После запуска всех инструкций из последовательности процессор переходи к
обработке следующей последовательности
-  Запуск инструкций из последовательности начинается, когда конфликты для всех инструкций разрешены.

EPIC предполагает выявление параллелизма уровня ILP(Instruction-Level Parallelism) программным путём (уровень компилятора) и формирование VLIW из независимых по данным машинных команд (обеспечивая т.о. параллелизм их выполнения)
# 52. Микроархитектуры Intel Haswell и Broadwell
>Всю инфу брал отсюда, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://www.ixbt.com/cpu/intel-haswell.shtml

Нa Bradwell перцев сам в лекциях болт забил

**Процессорная часть** Изменения в процессоре включают добавление новых инструкций и новых режимов энергосбережения, встраивание регулятора напряжения, а также изменения в самом процессорном ядре.

**Наборы инструкций** В архитектуре Haswell появились новые наборы инструкций. Их можно условно разделить на две большие группы: направленные на увеличение векторной производительности и направленные на серверный сегмент. К первым относятся AVX и FMA3, ко вторым — виртуализация и транзакционная память.

Haswell появилось новое расширение Transactional Synchronization Extensions (TSX) — транзакционная память, которая предназначена для эффективной реализации многопоточных программ и повышения их надежности. Данное расширение позволяет реализовать «в железе» транзакционную память, тем самым повысив общую производительность.
Что такое транзакционная память? Это такая память, которая имеет внутри себя механизм управления параллельными процессами для обеспечения доступа к совместно используемым данным. Расширение TSX состоит из двух компонентов: Hardware Lock Elision (HLE) и Restricted Transaction Memory (RTM).
Компонент RTM представляет собой набор инструкций, с помощью которого программист может начать, закончить и прервать транзакцию. Компонент HLE вводит префиксы, которые игнорируются процессорами без поддержки TSX. Префиксы обеспечивают блокировку переменных, позволяя другим процессам использовать (считывать) заблокированные переменные и исполнять свой код до тех пор, пока не произойдет конфликт записи заблокированных данных.

![Архитекрута](.images/52/architecture.png)


# 53. Микроархитектуры Intel Skylake и его наследники
>Всю инфу брал отсюда, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://3dnews.ru/919036/intel-skylake-podrobnosti-o-mikroarhitekture

![Четырёхъядерный Skylake-S с графикой GT2](images\53\processor.png)
Новая микроархитектура нацелена на одновременное декодирование до шести x86 CISC-инструкций, которые могут преобразовываться в шесть RISC-микроинструкций. Но, в отличие от его предшественников, число ситуаций, в которых Skylake сможет похвастать одновременным исполнением сразу шести полученных микроинструкций, то есть максимально эффективной загрузкой своего исполнительного конвейера, увеличится.

![Кэш](images\53\cache.png)
Основная идея состоит в том, что до сих пор eDRAM была напрямую связана с L3-кешем, получая из него данные, которые не могутв нём больше храниться. В новых же процессорах eDRAM взаимодействует не с процессорным кешем, а с контроллером памяти. Это означает две вещи. Во-первых, теперь eDRAM логически отвязана от процессора и с него снята забота о поддержании её когерентности. Во-вторых, кешироваться в eDRAM теперь могут абсолютно любые данные, поступающие в системную память, в том числе и те, которые помечены операционной системой как некешируемые, и даже те, которыми обменивается с памятью не процессор, а, например, PCI Express-устройства или графическое ядро.

Skylake есть и действительно революционное нововведение – технология Speed Shift, суть которой заключается в том, что процессору теперь даётся куда большая свобода действий в управлении собственными энергосберегающими состояниями.

**Графооооон**
![Gen9](images\53\GPU.png)
Графическое ядро Skylake может быть построено на базе одного или нескольких модулей, каждый из которых обычно включает в себя по три секции. Секции объединяют по восемь исполнительных устройств, на которые ложится основная часть обработки графических данных, а также содержат базовые блоки для работы с памятью и текстурные семплеры. Помимо исполнительных устройств, сгруппированных в модули, графическое ядро содержит и внемодульную часть, отвечающую за фиксированные геометрические преобразования и отдельные мультимедийные функции.

**Наследники(в лекциях про них инфы до пизды(ес че лк 13) я ток базу выпишу)**
- Intel Kaby Lake
    - release date: 30 августа 2016
        - Kaby Lake R – 21 августа 2017 для устройств пониженной мощности
        - Whiskey Lake (4-й кв. 2018) – мобильный сегмент с ультра-низким
энергопотреблением (5-7 Вт)
        - Amber Lake (4-й кв. 2018) – мобильный сегмент с ультра-низким
энергопотреблением (5-7 Вт)
    - особенности:
        - техпроцесс: 14 нм
        - USB 3.1 / Thunderbolt 3
        - Intel Optane (3D Xpoint)
- Intel Coffee Lake
    - release date: 5 октября 2017
    - особенности:
        - техпроцесс: 14 нм++
        - сегмент: десктоп / мобильный решения
        - 4-6 ядер
        - L3 кэш – 12 Мб
        - GPU Gen 9.5 
    - ![Coffie](images\53\Coffie.png)
- Intel Comet Lake
    - +25% ядер (до 10)
    - +25% LLC (до 20 MiB)
- Intel Rocket Lake
    - PCIE 4.0
# 54. Микроархитектура Intel Alder Lake
>Всю инфу брал отсюда, перцув в этот раз вообще инфу зажопил, советую читать статью, я вроде все важное взял, но кто знает...  https://3dnews.ru/1049571/pochemu-intel-alder-lake-glavniy-protsessor-etoy-oseni https://dzen.ru/a/Yio9VBSXAVj6el7J

- анонс: ноябрь 2021 года
- тех. процесс: Intel 7 (10nm ESF)
- ядра: 
    - Golden Cove (performance core, до 8)
    - Gracemont (efficiency core, до 8)
    - DDR5
    - Intel Xe-LP

Для реализации оптимального решения, инженеры в Intel объединили два типа ядер в одном чипе.
![Архитектура](images\54\arch.png)
Новая архитектура предоставляет до 8 производительных ядер и до 8 эффективных ядер. Intel назвала производительные ядра P-cores, а эффективные E-cores. Каждое производительное ядро поддерживает технологию Intel Hyper Threading. Итоговое количество потоков, является суммой потоков P-cores и E-cores.

Задачи, которые требовательны к производительности, в первую очередь будут выполняться на P-cores, а когда компьютер используется не активно, или задачи нетребовательны к производительности CPU, будут использованы ядра E-cores.

По сравнению с ядрами архитектуры “Skylake”, P-cores на основе микроархитектуры “Golden Cove” обеспечивают значительное увеличение IPC на 28%. На микроархитектуре “Skylake” работают пять поколений процессоров Core (с 6-го по 10-е). Ядра “Golden Cove” дают впечатляющий прирост на 19% в сравнении с ядрами “Cypress Cove” используемыми в 11-го поколения, архитектуры “Rocket Lake”.

Энергоэффективные E-cores на основе микроархитектуры “Gracemont” при правильной частоте и мощности могут соответствовать производительности ядер на основе архитектуры “Skylake”, занимая при этом четверть площади кристалла и долю мощности P-cores.
# 55. Микроархитектура AMD Zen
>Всю инфу брал отсюда + лк 14, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://3dnews.ru/948466/obzor-protsessora-amd-ryzen-7-1800x-neugeli-dogdalis

Одно из главных концептуальных изменений в Zen – это поддержка многопоточности и расчленение ядер. Прошлая микроархитектура, Bulldozer, предполагала разделение частей конвейера, FPU и SIMD-блоков, а также L2-кеша между сблокированными в модули парами ядер. Теперь же все эти ресурсы стали для каждого ядра полностью индивидуальны.
![Микроархитектура](images\55\arch1.png)
![Как примерно все расположено](images\55\complex.png)
![Как примерно все расположено на кристалле](images\55\core.png)

**Важные нововведения**
- Добавили кэш микроопераций
- Поддержка SMT:
    - разделение на основе квантования времени
    - на этапах предсказания ветвлений и переименования регистров выполняется анализ приоритетов
    - очередь микроопераций и очередь отставки продублированы
- механизм автоматического разгона процессора, зависящий от параметров его
системы охлаждения
- обучающаяся в реальном времени нейронная сеть
    - занимается предсказанием того, как поведёт себя приложение в ближайшем будущем
- Smart Prefetch
    - механизм предварительной выборки необходимых данный в L1 и L2 кеши
процессора
# 56. Микроархитектура AMD Zen 2 и наследников
>Всю инфу брал отсюда, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://3dnews.ru/989344/mikroarhitektura-zen-2
![Микроархитектура](images\56\arch.png)
![fetch](images\56\fetch.png)
![Схема](images\56\schema.png)

# 71. Микроархитектура NVIDIA Turing
>Всю инфу брал отсюда, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://www.ixbt.com/3dv/nvidia-geforce-20-overview.html
![Спецификации чипов семейства Turing](images\71\Chip_Specifiation.png)
![Полный чип](images\71\Chip_Full.png)
![Один кластер](images\71\Cluster.png)

# 72. Микроархитектура NVIDIA Ampere
- 3000-я серия GeForce RTX
- GA102, GA104, GA106
- NVIDIA A100
- GA100

# 73. Микроархитектура NVIDIA Hopper
![Архитектура](images\73\arch.png)
![SM](images\73\SM.png)
![TC](images\73\Tensor.png)

# 74. Микроархитектура NVIDIA Ada Lovelace
>Всю инфу брал отсюда, в лекциях этого вообще нет, советую читать статью, я вроде все важное взял, но кто знает...  https://boiling-machine.ru/blog/articles/arhitektura-ada-lovelace/
![Архитектура](images\74\arch.png)
Полноценный чип AD102 включает 12 кластеров обработки графики (GPC), 72 кластера обработки текстур (TPC), 144 потоковых мультипроцессора (SM) и 384-битный интерфейс памяти с 12 32-битными контроллерами памяти. Также стоит упомянуть о наличии у чипа 288 ядер FP64 (по 2 на SM). Скорость FP64 TFLOP составляет 1/64 от скорости TFLOP операций FP32. Небольшое количество ядер FP64 включено для обеспечения правильной работы любых программ с кодом FP64, включая код FP64 у тензорных ядер.

Таким образом, полноценный чип AD102 включает:
- 18432 ядра CUDA
- 144 ядра RT
- 576 тензорных ядер
- 576 текстурных блоков
![GPC](images\74\GPC.png)
Каждый SM (потоковый мультипроцессор) в чипах AD10x содержит:
- 128 ядер CUDA
- одно ядро ​​RT Ada третьего поколения
- четыре тензорных ядра Ada четвертого поколения
- четыре текстурных блока
- регистровый файл размером 256 КБ
- 128 КБ L1-кэша, которые можно настроить в зависимости от потребностей графики или вычислительной нагрузки

![SM](images\74\SM.png)
- регистровый файл размером 64 КБ
- кэш инструкций L0
- один планировщик деформации
- один блок диспетчеризации
- 16 ядер CUDA, предназначенных для обработки FP32 (до 16 операций FP32 за такт)
- 16 ядер CUDA, которые могут обрабатывать операции FP32 или INT32 (16 операций FP32 за такт ИЛИ 16 операций INT32 за такт)
- одно тензорное ядро Ada четвертого поколения
- четыре блока загрузки/сохранения
- блок специальных функций (SFU), который выполняет трансцендентные и графические инструкции интерполяции

# 75. Микроархитектура NVIDIA Volta
>Всю инфу брал отсюда, как и перцев, советую читать статью, я вроде все важное взял, но кто знает...  https://www.ixbt.com/video4/nvidia-volta.shtml

- новый дизайн потокового мультипроцессора
- оптимизация для задач глубокого обучения
- появились Tensor Cores (тензорные ядра)
-  независимые параллельные потоки данных для целочисленных вычислений и
вычислений с плавающей запятой
- новая объединенная подсистема кэширования данных первого уровня (L1-кэш) и разделяемой памяти (Shared Memory)
- технология высокоскоростных соединений NVLink 2.0
- до шести 25 ГБ/с каналов NVLink
- общая пропускная способность в 300 ГБ/с
- объем: 16 ГБ
- функция Multi-Process Service (MPS) возможность несколькими процессами использовать совместно один и тот же GPU число клиентов: 48
![Архиьтектура](images\75\arch.png)
- 6 GPC
- 42 TPC
- 84 SM
- 8 новых тензорных ядер
![SM](images\75\SM.png)
- Новые тензорные ядра со смешанной точностью вычислений (FP16/FP32),
предназначенные для матричных вычислений, используемых в задачах глубокого обучения;
- Улучшенная кэш-память первого уровня с лучшей производительностью и
сниженными задержками доступа
- Оптимизированный набор инструкций для упрощения декодирования и
сокращения задержек при исполнении инструкций
- Специальные оптимизации для достижения высокой тактовой частоты и лучшей
энергоэффективности
- четыре блока обработки
- по 16 FP32-ядер
- по 8 FP64-ядер
- по 16 INT32-ядер
- новый кэш инструкций нулевого уровня (L0)
- один планировщик варпов
- раздельные FP32 и INT32 модули

![Тензорные ядра](images\75\tensor.png)
GPU архитектуры Volta поддерживает новые инструкции и форматы данных, удобные для обработки массивов матриц 4×4. Каждое тензорное ядро обрабатывает матричный массив 4×4×4, выполняя операцию D = A × B + C, где A, B, C и D — это матрицы размером 4×4. Вычислительные ядра считывают два значения с FP16-точностью, упакованные в один регистр (матрицы A и B), их перемножение осуществляется с FP32-точностью, результат суммируется с FP32- или FP16-значением и записывается с 32-битной или 16-битной точностью. Для задач глубокого обучения такой точности вполне достаточно, и вполне может быть, что способности тензорных ядер пригодятся также и в других задачах.